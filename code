from functools import total_ordering, singledispatchmethod, wraps
from typing import Any

def decor(func: object) -> object:
    @wraps(func)
    def new_func(self, total: object, *args: Any, **kwargs: Any) -> Any:
        if isinstance(total, self.__class__|int|float):
            return func(self, total, *args, **kwargs)
        return NotImplemented
    return new_func

def rsign(sign: object) -> object:
    @decor
    def update(self, total: object) -> int:
        return eval(f'{total} {sign} {int(self)}')
    return update

@total_ordering
class RomanNumeral:
    """
       working with roman numerals.
       attribute post - dict roman numerals
       attribute num - roman numeral now
       staticmethod parch - algorithm
    """

    post = {
            '': 0, 'I': 1, 'V': 5, 'X': 10, 
            'L': 50, 'C': 100, 'D': 500,
            'M': 1000
           }
    
    @singledispatchmethod
    def __init__(self, number: str) -> None:
        if isinstance(number, str) and number.strip(''.join(self.post)) == '':
            object.__setattr__(self, 'num', number)
        else:
            raise ValueError('переданный объект не являеться римским/арабским числом')
    
    @__init__.register
    def new__init__(self, number: int|float) -> None:
        if number:
            object.__setattr__(self, 'num', self.patch(RomanNumeral('I'), number - 1, '+').num)
        else:
            raise ValueError('ноль не поддерживаеться в римской системе счисления')

    def __str__(self) -> str:
        return f'{self.num}'

    def __int__(self) -> int:
        wow, count = tuple(self.post[i] for i in self.num), 0
        for i, j in enumerate(wow[:-1], 1):
            count += (j if j >= wow[i] else -j)
        return count + wow[-1]
    
    @decor
    def __eq__(self, total: object) -> bool:
        return int(self) == int(total)

    
    def __hash__(self) -> int:
        return hash(int(self))
    
    @decor
    def __gt__(self, total: object) -> bool:
        return int(self) > int(total)

    @decor
    def __add__(self, total: object) -> object:
        return self.patch(self, total, '+')

    @decor
    def __sub__(self, total: object) -> object:
        return self.patch(self, total, '-')
    
    @decor
    def __mul__(self, total: object) -> object:
        return self.patch(self, total, '*')
    
    @decor
    def __truediv__(self, total: object) -> object:
        return self.patch(self, total, '/')
    
    @decor
    def __floordiv__(self, total: object) -> object:
        return self.patch(self, total, '//')
    
    @decor 
    def __mod__(self, total: object) -> object:
        return self.patch(self, total, '%')
    
    def __bool__(self) -> bool:
        return True
    
    def __setattr__(self, *_) -> ValueError:
        raise ValueError('Устанавливать/Изменять атрибуты, данному экземпляру класса - нельзя')
    
    def __delattr__(self, *_) -> ValueError:
        raise ValueError('Удалять атрибуты экземпляра класса - нельзя')
    
    __radd__ = rsign('+')
    __rsub__ = rsign('-')
    __rmul__ = rsign('*')
    __rtruediv__ = rsign('/')
    __rfloordiv__ = rsign('//')
    __rmod__ = rsign('%')
    
    @staticmethod
    def patch(instance: object, total: object, sign: str) -> object:
        digit, dicts = eval(f'{int(instance)} {sign} {int(total)}'), [*reversed(instance.post.items())]
        count = ''
        for j in range(len(dicts) - 1):
            element_a, element_b = dicts[j], dicts[j + 1][1]
            while digit // element_a[1] >= 1:
                digit -= element_a[1]
                count = f'{count}{element_a[0]}'
            if digit < element_a[1] and digit > element_b:
                for one, two in reversed(dicts[j + 1:]):
                    if digit // (element_a[1] - two) >= 1 and str(two)[0] != '5':
                        digit -= (element_a[1] - two)
                        count = f'{count}{one}{element_a[0]}'
        return instance.__class__(count)
